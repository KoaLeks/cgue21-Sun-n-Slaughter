#version 430 core

layout (quads, fractional_even_spacing, ccw) in;
 
in vec4 tcPosition[];
in vec4 tcFragPosLightSpace[];

uniform mat4 modelMatrix;
uniform mat4 viewProjMatrix;
uniform sampler2D heightMap;
uniform float scaleXZ;
uniform float scaleY;

out vec4 teNormal;
out vec4 tePosition;
out vec2 teTextureCoordinate;
out vec4 teFragPosLightSpace;

// https://stackoverflow.com/questions/5281261/generating-a-normal-map-from-a-height-map
void main()
{
    vec4 adPosition = mix(tcPosition[0], tcPosition[3], gl_TessCoord.x);
    vec4 bcPosition = mix(tcPosition[1], tcPosition[2], gl_TessCoord.x);
    vec4 position = mix(adPosition, bcPosition, gl_TessCoord.y);

    vec4 adFragPosLightSpace = mix(tcFragPosLightSpace[0], tcFragPosLightSpace[3], gl_TessCoord.x);
    vec4 bcFragPosLightSpace = mix(tcFragPosLightSpace[1], tcFragPosLightSpace[2], gl_TessCoord.x);
    teFragPosLightSpace = mix(adFragPosLightSpace, bcFragPosLightSpace, gl_TessCoord.y);

    vec2 textureCoordinate = position.xz / scaleXZ;
    teTextureCoordinate = textureCoordinate;

    float height = texture(heightMap, textureCoordinate).r * scaleY;
    vec4 newPos = vec4(position.x, height, position.z, 1.0);
	mat4 mvp = viewProjMatrix * modelMatrix;

    const ivec3 off = ivec3(-1, 0, 1);

    float s01 = scaleY * textureOffset(heightMap, textureCoordinate, off.xy).x;
    float s21 = scaleY * textureOffset(heightMap, textureCoordinate, off.zy).x;
    float s10 = scaleY * textureOffset(heightMap, textureCoordinate, off.yx).x;
    float s12 = scaleY * textureOffset(heightMap, textureCoordinate, off.yz).x;
    vec3 va = normalize(vec3(2, s21-s01, 0));
    vec3 vb = normalize(vec3(0, s12-s10, -2));
    
    teNormal = vec4( cross(va,vb), height );
    
    tePosition = newPos;
    gl_Position = mvp * newPos;
}